<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>new_sokoban_solver: Util Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">new_sokoban_solver
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_util.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_util-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Util Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains a set of utilitary methodes.  
 <a href="class_util.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="util_8h_source.html">util.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0670a004f4e488d0fb1256d7bb3c96ca"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util.html#a0670a004f4e488d0fb1256d7bb3c96ca">Util</a> ()</td></tr>
<tr class="memdesc:a0670a004f4e488d0fb1256d7bb3c96ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor of class <a class="el" href="class_util.html" title="Contains a set of utilitary methodes.">Util</a>.  <a href="#a0670a004f4e488d0fb1256d7bb3c96ca">More...</a><br /></td></tr>
<tr class="separator:a0670a004f4e488d0fb1256d7bb3c96ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e7ca60d9570966cb4eedbc187475f7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util.html#a99e7ca60d9570966cb4eedbc187475f7">~Util</a> ()</td></tr>
<tr class="memdesc:a99e7ca60d9570966cb4eedbc187475f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor of class <a class="el" href="class_util.html" title="Contains a set of utilitary methodes.">Util</a>.  <a href="#a99e7ca60d9570966cb4eedbc187475f7">More...</a><br /></td></tr>
<tr class="separator:a99e7ca60d9570966cb4eedbc187475f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aee4b341e7ec898464713eef2d36a5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util.html#a7aee4b341e7ec898464713eef2d36a5a">vider</a> (std::queue&lt; unsigned short &gt; &amp;t)</td></tr>
<tr class="memdesc:a7aee4b341e7ec898464713eef2d36a5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty the queue sent in parameter.  <a href="#a7aee4b341e7ec898464713eef2d36a5a">More...</a><br /></td></tr>
<tr class="separator:a7aee4b341e7ec898464713eef2d36a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d9ef13d5ba8783838bb4f7529606b1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util.html#a5d9ef13d5ba8783838bb4f7529606b1c">vider</a> (std::queue&lt; std::vector&lt; unsigned char &gt;&gt; &amp;t)</td></tr>
<tr class="memdesc:a5d9ef13d5ba8783838bb4f7529606b1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty the queue sent in parameter.  <a href="#a5d9ef13d5ba8783838bb4f7529606b1c">More...</a><br /></td></tr>
<tr class="separator:a5d9ef13d5ba8783838bb4f7529606b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac33fb3cde8b729ddc62e1367dc976367"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util.html#ac33fb3cde8b729ddc62e1367dc976367">vider</a> (std::queue&lt; BFSCase_relier_point &gt; &amp;queue)</td></tr>
<tr class="memdesc:ac33fb3cde8b729ddc62e1367dc976367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty the queue sent in parameter.  <a href="#ac33fb3cde8b729ddc62e1367dc976367">More...</a><br /></td></tr>
<tr class="separator:ac33fb3cde8b729ddc62e1367dc976367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a061e6335888dfe43bb0288a01a82eaac"><td class="memItemLeft" align="right" valign="top">std::unordered_set&lt; unsigned short &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util.html#a061e6335888dfe43bb0288a01a82eaac">detectAgglomerateOFBoxes</a> (<a class="el" href="class_maze.html">Maze</a> *m, short initBox, unsigned short depht)</td></tr>
<tr class="memdesc:a061e6335888dfe43bb0288a01a82eaac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect if an aglomerat of box exist around a box.  <a href="#a061e6335888dfe43bb0288a01a82eaac">More...</a><br /></td></tr>
<tr class="separator:a061e6335888dfe43bb0288a01a82eaac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9fca4ae7c3ba74844a88567f49f1504"><td class="memItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util.html#ad9fca4ae7c3ba74844a88567f49f1504">calcZoneAccessible</a> (const <a class="el" href="class_maze.html">Maze</a> *m, short &amp;normPos)</td></tr>
<tr class="memdesc:ad9fca4ae7c3ba74844a88567f49f1504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the accissble Zone of the <a class="el" href="class_maze.html">Maze</a>.  <a href="#ad9fca4ae7c3ba74844a88567f49f1504">More...</a><br /></td></tr>
<tr class="separator:ad9fca4ae7c3ba74844a88567f49f1504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03161a201731432ae5a9f9742db14e77"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util.html#a03161a201731432ae5a9f9742db14e77">relier_point</a> (<a class="el" href="class_maze.html">Maze</a> m, std::vector&lt; unsigned short &gt; positions)</td></tr>
<tr class="memdesc:a03161a201731432ae5a9f9742db14e77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will convert successive position in a vector of direction to take for reach all this positions.  <a href="#a03161a201731432ae5a9f9742db14e77">More...</a><br /></td></tr>
<tr class="separator:a03161a201731432ae5a9f9742db14e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14fa4ece4810419561f99a29ba4cabd0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util.html#a14fa4ece4810419561f99a29ba4cabd0">choose_level</a> ()</td></tr>
<tr class="memdesc:a14fa4ece4810419561f99a29ba4cabd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ask the player to choose a level.  <a href="#a14fa4ece4810419561f99a29ba4cabd0">More...</a><br /></td></tr>
<tr class="separator:a14fa4ece4810419561f99a29ba4cabd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319a5e7e6ca70fb2e765f9571bc8d4a6"><td class="memItemLeft" align="right" valign="top">std::deque&lt; short &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util.html#a319a5e7e6ca70fb2e765f9571bc8d4a6">getPathSquareToGoalBM</a> (const <a class="el" href="class_maze.html">Maze</a> *m, short squareID)</td></tr>
<tr class="memdesc:a319a5e7e6ca70fb2e765f9571bc8d4a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calcul the path beetween a square and the neared Goal in BM.  <a href="#a319a5e7e6ca70fb2e765f9571bc8d4a6">More...</a><br /></td></tr>
<tr class="separator:a319a5e7e6ca70fb2e765f9571bc8d4a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b4b5b6d151e6fb4388a26f5fea13c70"><td class="memItemLeft" align="right" valign="top">std::deque&lt; short &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util.html#a5b4b5b6d151e6fb4388a26f5fea13c70">getPathSquareToSquareBM</a> (const <a class="el" href="class_maze.html">Maze</a> *m, short fromSquare, short toSquare)</td></tr>
<tr class="memdesc:a5b4b5b6d151e6fb4388a26f5fea13c70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the path beetween the squareID send in parameters and the toSquare.  <a href="#a5b4b5b6d151e6fb4388a26f5fea13c70">More...</a><br /></td></tr>
<tr class="separator:a5b4b5b6d151e6fb4388a26f5fea13c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdcf4621797b62bd2a1268000a62556c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_node_1_1_node_retrack_info.html">Node::NodeRetrackInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util.html#afdcf4621797b62bd2a1268000a62556c">getPathSquareToSquareZoneMethod</a> (const <a class="el" href="class_maze.html">Maze</a> *m, short fromSquare, short toSquare, short posPlayer)</td></tr>
<tr class="memdesc:afdcf4621797b62bd2a1268000a62556c"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the path beewteen fromSquare and toSquare with BFSPlus like method  <a href="#afdcf4621797b62bd2a1268000a62556c">More...</a><br /></td></tr>
<tr class="separator:afdcf4621797b62bd2a1268000a62556c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc64fdff8e06835f673d329db43c9ce3"><td class="memItemLeft" align="right" valign="top">std::deque&lt; short &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util.html#afc64fdff8e06835f673d329db43c9ce3">getPathSquareToSquarePM</a> (const <a class="el" href="class_maze.html">Maze</a> *m, short fromSquare, short toSquare)</td></tr>
<tr class="memdesc:afc64fdff8e06835f673d329db43c9ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the path beetween 2 square in PM, ignore boxes.  <a href="#afc64fdff8e06835f673d329db43c9ce3">More...</a><br /></td></tr>
<tr class="separator:afc64fdff8e06835f673d329db43c9ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb429d34d5900b53ee165bcfdb2e370f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; short &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util.html#adb429d34d5900b53ee165bcfdb2e370f">getDistMapOfSquare</a> (const <a class="el" href="class_maze.html">Maze</a> *m, short toSquare)</td></tr>
<tr class="memdesc:adb429d34d5900b53ee165bcfdb2e370f"><td class="mdescLeft">&#160;</td><td class="mdescRight">return dist map of toSquare (in BM)  <a href="#adb429d34d5900b53ee165bcfdb2e370f">More...</a><br /></td></tr>
<tr class="separator:adb429d34d5900b53ee165bcfdb2e370f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322f66b7df9815c69ab1df347c252b6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util.html#a322f66b7df9815c69ab1df347c252b6b">dispVector</a> (const <a class="el" href="class_maze.html">Maze</a> *m, std::vector&lt; short &gt; vec)</td></tr>
<tr class="memdesc:a322f66b7df9815c69ab1df347c252b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Display a vector of the size of the field.  <a href="#a322f66b7df9815c69ab1df347c252b6b">More...</a><br /></td></tr>
<tr class="separator:a322f66b7df9815c69ab1df347c252b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fad18144ea99148e70372ea56383751"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util.html#a2fad18144ea99148e70372ea56383751">dispVector</a> (const <a class="el" href="class_maze.html">Maze</a> *m, std::vector&lt; bool &gt; vec)</td></tr>
<tr class="memdesc:a2fad18144ea99148e70372ea56383751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Display a vector of the size of the field.  <a href="#a2fad18144ea99148e70372ea56383751">More...</a><br /></td></tr>
<tr class="separator:a2fad18144ea99148e70372ea56383751"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains a set of utilitary methodes. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0670a004f4e488d0fb1256d7bb3c96ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0670a004f4e488d0fb1256d7bb3c96ca">&#9670;&nbsp;</a></span>Util()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Util::Util </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor of class <a class="el" href="class_util.html" title="Contains a set of utilitary methodes.">Util</a>. </p>

</div>
</div>
<a id="a99e7ca60d9570966cb4eedbc187475f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99e7ca60d9570966cb4eedbc187475f7">&#9670;&nbsp;</a></span>~Util()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Util::~Util </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor of class <a class="el" href="class_util.html" title="Contains a set of utilitary methodes.">Util</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad9fca4ae7c3ba74844a88567f49f1504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9fca4ae7c3ba74844a88567f49f1504">&#9670;&nbsp;</a></span>calcZoneAccessible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; bool &gt; Util::calcZoneAccessible </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_maze.html">Maze</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short &amp;&#160;</td>
          <td class="paramname"><em>normPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the accissble Zone of the <a class="el" href="class_maze.html">Maze</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td><a class="el" href="class_maze.html">Maze</a> </td></tr>
    <tr><td class="paramname">normPos</td><td>normalize positions of the player </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the accesible zone + the normalize position (in parameters)</dd></dl>
<p>The accesible zone is the zone that the player can reach without having to push a box <br />
 The normalize Position is the most top and most left square that the player can reach <br />
 Calculate all the accesble square in the field with BFS (endless bfs which end the the queue is empty) </p>

</div>
</div>
<a id="a14fa4ece4810419561f99a29ba4cabd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14fa4ece4810419561f99a29ba4cabd0">&#9670;&nbsp;</a></span>choose_level()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Util::choose_level </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ask the player to choose a level. </p>
<dl class="section return"><dt>Returns</dt><dd>the path of the level choose by the player</dd></dl>
<p>Permet de choisir un niveau a jouer. Renvoit le chemin du niveau en String </p><dl class="section return"><dt>Returns</dt><dd>renvoit le chemin du niveau </dd></dl>

</div>
</div>
<a id="a061e6335888dfe43bb0288a01a82eaac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a061e6335888dfe43bb0288a01a82eaac">&#9670;&nbsp;</a></span>detectAgglomerateOFBoxes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt; unsigned short &gt; Util::detectAgglomerateOFBoxes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_maze.html">Maze</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>initBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>depht</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detect if an aglomerat of box exist around a box. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td><a class="el" href="class_maze.html">Maze</a> </td></tr>
    <tr><td class="paramname">initBox</td><td>position of the box to check </td></tr>
    <tr><td class="paramname"></td><td>depht will define wich depht level we wants for our aglomerat </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of all the box forming an aglomerat (the one sent in paramters will also be in this vector)</dd></dl>
<p>An aglomerat is when many box are touching each other</p>
<p>fait un mini BFS pour localiser la presence d'un aglomerat de box autour de celle envoyer en parametre </p>

</div>
</div>
<a id="a322f66b7df9815c69ab1df347c252b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a322f66b7df9815c69ab1df347c252b6b">&#9670;&nbsp;</a></span>dispVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Util::dispVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_maze.html">Maze</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; short &gt;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Display a vector of the size of the field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Maze* </td></tr>
    <tr><td class="paramname">vec</td><td>vector to display </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="a2fad18144ea99148e70372ea56383751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fad18144ea99148e70372ea56383751">&#9670;&nbsp;</a></span>dispVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Util::dispVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_maze.html">Maze</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Display a vector of the size of the field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Maze* </td></tr>
    <tr><td class="paramname">vec</td><td>vector to display </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="adb429d34d5900b53ee165bcfdb2e370f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb429d34d5900b53ee165bcfdb2e370f">&#9670;&nbsp;</a></span>getDistMapOfSquare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; short &gt; Util::getDistMapOfSquare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_maze.html">Maze</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>toSquare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return dist map of toSquare (in BM) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Maze* </td></tr>
    <tr><td class="paramname">toSquare</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>distMap of toSquare</dd></dl>
<p>a dist map is a vector of the size of the field, which for each square it has for value the distance from toSquare</p>
<p>return the dist map to go to this. calcuate in ignoring box calcuate in "pushingBox movement" </p>

</div>
</div>
<a id="a319a5e7e6ca70fb2e765f9571bc8d4a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a319a5e7e6ca70fb2e765f9571bc8d4a6">&#9670;&nbsp;</a></span>getPathSquareToGoalBM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; short &gt; Util::getPathSquareToGoalBM </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_maze.html">Maze</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>square</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calcul the path beetween a square and the neared Goal in BM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>: <a class="el" href="class_maze.html">Maze</a> </td></tr>
    <tr><td class="paramname">squareID</td><td>square to find the path </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the path beetween the squareID send in parameters and the nearest goal. <br />
 Will return null if no possible path</dd></dl>
<p>BM: box movement (path is like a path if we push a box)</p>
<p>Return the path beetween the square send in parameters and the nearest goal. If no possible path, return empty vector path is the id of all the square. calculating in "pushingBox movement" </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">:squareID</td><td>number of the square in the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the square can not reached a goal, return empty vector. If it is a wall or a goal return empty vector else will return a path of all the square ID to reach the goal </dd></dl>
<p>Si il ne s'agit pas d'une case marquable comme deadSquare</p>

</div>
</div>
<a id="a5b4b5b6d151e6fb4388a26f5fea13c70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b4b5b6d151e6fb4388a26f5fea13c70">&#9670;&nbsp;</a></span>getPathSquareToSquareBM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; short &gt; Util::getPathSquareToSquareBM </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_maze.html">Maze</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>fromSquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>toSquare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the path beetween the squareID send in parameters and the toSquare. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Maze* </td></tr>
    <tr><td class="paramname">fromSquare</td><td>begging square </td></tr>
    <tr><td class="paramname">toSquare</td><td>goal square </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the path beetween the squareID send in parameters and the toSquare goal. <br />
 path is the id of all the square</dd></dl>
<p>BM: box movement (path is like a path if we push a box)</p>
<p>Return the path beetween the fromSquare send in parameters and the toSquare . If no possible path, return empty vector path is the id of all the square. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">:fromSquare</td><td>number of the square in the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the square can not reached a goal, return empty vector. If it is a wall or a goal return empty vector else will return a path of all the square ID to reach the goal calculating in "pushingBox movement" </dd></dl>
<p>Si il ne s'agit pas d'une case marquable comme deadSquare</p>

</div>
</div>
<a id="afc64fdff8e06835f673d329db43c9ce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc64fdff8e06835f673d329db43c9ce3">&#9670;&nbsp;</a></span>getPathSquareToSquarePM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; short &gt; Util::getPathSquareToSquarePM </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_maze.html">Maze</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>fromSquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>toSquare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the path beetween 2 square in PM, ignore boxes. </p>
<p>Return the path beetween the fromSquare send in parameters and the toSquare . If no possible path, return empty vector path is the id of all the square </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Maze* </td></tr>
    <tr><td class="paramname">fromSquare</td><td></td></tr>
    <tr><td class="paramname">toSquare</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of square representing the path beetween fromSquare nd twoSquare PM: player like movement</dd></dl>
<p>Return the path beetween the fromSquare send in parameters and the toSquare . If no possible path, return empty vector path is the id of all the square. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">:fromSquare</td><td>number of the square in the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the square can not reached a goal, return empty vector. If it is a wall or a goal return empty vector else will return a path of all the square ID to reach the goal calculating in "moving player movement" </dd></dl>
<p>Si il ne s'agit pas d'une case marquable comme deadSquare</p>

</div>
</div>
<a id="afdcf4621797b62bd2a1268000a62556c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdcf4621797b62bd2a1268000a62556c">&#9670;&nbsp;</a></span>getPathSquareToSquareZoneMethod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_node_1_1_node_retrack_info.html">Node::NodeRetrackInfo</a> &gt; Util::getPathSquareToSquareZoneMethod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_maze.html">Maze</a> *&#160;</td>
          <td class="paramname"><em>orM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>fromSquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>toSquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>posPlayer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the path beewteen fromSquare and toSquare with BFSPlus like method </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td><a class="el" href="class_maze.html">Maze</a> </td></tr>
    <tr><td class="paramname">fromSquare</td><td>(must be accessible from posPlayer) </td></tr>
    <tr><td class="paramname">toSquare</td><td></td></tr>
    <tr><td class="paramname">posPlayer</td><td>position of the player </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of NodeRetrackInfo representing all the node to take for retracing the path</dd></dl>
<p>return the path beewteen fromSquare and toSquare with BFSPlus like method </p>
<p>We set the game in the state</p>
<p>we look for pushed all boxes in all directions possibles</p>

</div>
</div>
<a id="a03161a201731432ae5a9f9742db14e77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03161a201731432ae5a9f9742db14e77">&#9670;&nbsp;</a></span>relier_point()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned char &gt; Util::relier_point </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_maze.html">Maze</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned short &gt;&#160;</td>
          <td class="paramname"><em>positions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Will convert successive position in a vector of direction to take for reach all this positions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td><a class="el" href="class_maze.html">Maze</a> </td></tr>
    <tr><td class="paramname">positions</td><td>list of positions to reach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector containing all the directions to follow</dd></dl>
<p>this method will receive a vector of succesive position. it will give in return a vector of move directctive to follow in passed through each position of the vector </p>

</div>
</div>
<a id="a7aee4b341e7ec898464713eef2d36a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aee4b341e7ec898464713eef2d36a5a">&#9670;&nbsp;</a></span>vider() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Util::vider </td>
          <td>(</td>
          <td class="paramtype">std::queue&lt; unsigned short &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Empty the queue sent in parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>queue to Empty </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d9ef13d5ba8783838bb4f7529606b1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d9ef13d5ba8783838bb4f7529606b1c">&#9670;&nbsp;</a></span>vider() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Util::vider </td>
          <td>(</td>
          <td class="paramtype">std::queue&lt; std::vector&lt; unsigned char &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Empty the queue sent in parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>queue to Empty </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac33fb3cde8b729ddc62e1367dc976367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac33fb3cde8b729ddc62e1367dc976367">&#9670;&nbsp;</a></span>vider() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Util::vider </td>
          <td>(</td>
          <td class="paramtype">std::queue&lt; BFSCase_relier_point &gt; &amp;&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Empty the queue sent in parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>queue to Empty </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="util_8h_source.html">util.h</a></li>
<li><a class="el" href="util_8cpp.html">util.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_util.html">Util</a></li>
    <li class="footer">Generated on Wed Jun 12 2019 15:10:34 for new_sokoban_solver by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
