<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>new_sokoban_solver: Util Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">new_sokoban_solver
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_util.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_util-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Util Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util_1_1_b_f_s_case__relier__point.html">BFSCase_relier_point</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7aee4b341e7ec898464713eef2d36a5a"><td class="memItemLeft" align="right" valign="top"><a id="a7aee4b341e7ec898464713eef2d36a5a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>vider</b> (std::queue&lt; unsigned short &gt; &amp;t)</td></tr>
<tr class="separator:a7aee4b341e7ec898464713eef2d36a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d9ef13d5ba8783838bb4f7529606b1c"><td class="memItemLeft" align="right" valign="top"><a id="a5d9ef13d5ba8783838bb4f7529606b1c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>vider</b> (std::queue&lt; std::vector&lt; unsigned char &gt;&gt; &amp;t)</td></tr>
<tr class="separator:a5d9ef13d5ba8783838bb4f7529606b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac33fb3cde8b729ddc62e1367dc976367"><td class="memItemLeft" align="right" valign="top"><a id="ac33fb3cde8b729ddc62e1367dc976367"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>vider</b> (std::queue&lt; <a class="el" href="class_util_1_1_b_f_s_case__relier__point.html">BFSCase_relier_point</a> &gt; &amp;queue)</td></tr>
<tr class="separator:ac33fb3cde8b729ddc62e1367dc976367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89c7d9bec5823cd8c2be163972cd9c5b"><td class="memItemLeft" align="right" valign="top">std::unordered_set&lt; unsigned short &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util.html#a89c7d9bec5823cd8c2be163972cd9c5b">detectAgglomerateOFBoxes</a> (<a class="el" href="class_maze.html">Maze</a> *m, short boxes)</td></tr>
<tr class="separator:a89c7d9bec5823cd8c2be163972cd9c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9fca4ae7c3ba74844a88567f49f1504"><td class="memItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util.html#ad9fca4ae7c3ba74844a88567f49f1504">calcZoneAccessible</a> (const <a class="el" href="class_maze.html">Maze</a> *m, short &amp;normPos)</td></tr>
<tr class="separator:ad9fca4ae7c3ba74844a88567f49f1504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a447f63eecf30c3258e5bf7b8e32f3864"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned short &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util.html#a447f63eecf30c3258e5bf7b8e32f3864">relier_point</a> (<a class="el" href="class_maze.html">Maze</a> m, std::vector&lt; unsigned short &gt;)</td></tr>
<tr class="separator:a447f63eecf30c3258e5bf7b8e32f3864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14fa4ece4810419561f99a29ba4cabd0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util.html#a14fa4ece4810419561f99a29ba4cabd0">choose_level</a> ()</td></tr>
<tr class="separator:a14fa4ece4810419561f99a29ba4cabd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319a5e7e6ca70fb2e765f9571bc8d4a6"><td class="memItemLeft" align="right" valign="top">std::deque&lt; short &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util.html#a319a5e7e6ca70fb2e765f9571bc8d4a6">getPathSquareToGoalBM</a> (const <a class="el" href="class_maze.html">Maze</a> *m, short squareID)</td></tr>
<tr class="separator:a319a5e7e6ca70fb2e765f9571bc8d4a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b4b5b6d151e6fb4388a26f5fea13c70"><td class="memItemLeft" align="right" valign="top">std::deque&lt; short &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util.html#a5b4b5b6d151e6fb4388a26f5fea13c70">getPathSquareToSquareBM</a> (const <a class="el" href="class_maze.html">Maze</a> *m, short fromSquare, short toSquare)</td></tr>
<tr class="separator:a5b4b5b6d151e6fb4388a26f5fea13c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdcf4621797b62bd2a1268000a62556c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_node_1_1_node_retrack_info.html">Node::NodeRetrackInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util.html#afdcf4621797b62bd2a1268000a62556c">getPathSquareToSquareZoneMethod</a> (const <a class="el" href="class_maze.html">Maze</a> *m, short fromSquare, short toSquare, short posPlayer)</td></tr>
<tr class="separator:afdcf4621797b62bd2a1268000a62556c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc64fdff8e06835f673d329db43c9ce3"><td class="memItemLeft" align="right" valign="top">std::deque&lt; short &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util.html#afc64fdff8e06835f673d329db43c9ce3">getPathSquareToSquarePM</a> (const <a class="el" href="class_maze.html">Maze</a> *m, short fromSquare, short toSquare)</td></tr>
<tr class="separator:afc64fdff8e06835f673d329db43c9ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb429d34d5900b53ee165bcfdb2e370f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; short &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util.html#adb429d34d5900b53ee165bcfdb2e370f">getDistMapOfSquare</a> (const <a class="el" href="class_maze.html">Maze</a> *m, short toSquare)</td></tr>
<tr class="separator:adb429d34d5900b53ee165bcfdb2e370f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322f66b7df9815c69ab1df347c252b6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_util.html#a322f66b7df9815c69ab1df347c252b6b">dispVector</a> (const <a class="el" href="class_maze.html">Maze</a> *m, std::vector&lt; short &gt; vec)</td></tr>
<tr class="separator:a322f66b7df9815c69ab1df347c252b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fad18144ea99148e70372ea56383751"><td class="memItemLeft" align="right" valign="top"><a id="a2fad18144ea99148e70372ea56383751"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dispVector</b> (const <a class="el" href="class_maze.html">Maze</a> *m, std::vector&lt; bool &gt; vec)</td></tr>
<tr class="separator:a2fad18144ea99148e70372ea56383751"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad9fca4ae7c3ba74844a88567f49f1504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9fca4ae7c3ba74844a88567f49f1504">&#9670;&nbsp;</a></span>calcZoneAccessible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; bool &gt; Util::calcZoneAccessible </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_maze.html">Maze</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short &amp;&#160;</td>
          <td class="paramname"><em>normPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate all the accesble square in the field with BFS (endless bfs which end the the queue is empty) </p>

</div>
</div>
<a id="a14fa4ece4810419561f99a29ba4cabd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14fa4ece4810419561f99a29ba4cabd0">&#9670;&nbsp;</a></span>choose_level()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Util::choose_level </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Permet de choisir un niveau a jouer. Renvoit le chemin du niveau en String </p><dl class="section return"><dt>Returns</dt><dd>renvoit le chemin du niveau </dd></dl>

</div>
</div>
<a id="a89c7d9bec5823cd8c2be163972cd9c5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89c7d9bec5823cd8c2be163972cd9c5b">&#9670;&nbsp;</a></span>detectAgglomerateOFBoxes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt; unsigned short &gt; Util::detectAgglomerateOFBoxes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_maze.html">Maze</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>initBox</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>fait un mini BFS pour localiser la presence d'un aglomerat de box autour de celle envoyer en parametre </p>

</div>
</div>
<a id="a322f66b7df9815c69ab1df347c252b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a322f66b7df9815c69ab1df347c252b6b">&#9670;&nbsp;</a></span>dispVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Util::dispVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_maze.html">Maze</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; short &gt;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>display a vector of the size of the field </p>

</div>
</div>
<a id="adb429d34d5900b53ee165bcfdb2e370f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb429d34d5900b53ee165bcfdb2e370f">&#9670;&nbsp;</a></span>getDistMapOfSquare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; short &gt; Util::getDistMapOfSquare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_maze.html">Maze</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>toSquare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>return the dist map to go to this. calcuate in ignoring box calcuate in "pushingBox movement" </p>

</div>
</div>
<a id="a319a5e7e6ca70fb2e765f9571bc8d4a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a319a5e7e6ca70fb2e765f9571bc8d4a6">&#9670;&nbsp;</a></span>getPathSquareToGoalBM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; short &gt; Util::getPathSquareToGoalBM </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_maze.html">Maze</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>square</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the path beetween the squareID send in parameters and the nearest goal. If no possible path, return null path is the id of all the square BM: box movement (path is like a path if we push a box)</p>
<p>Return the path beetween the square send in parameters and the nearest goal. If no possible path, return empty vector path is the id of all the square. calculating in "pushingBox movement" </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">:squareID</td><td>number of the square in the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the square can not reached a goal, return empty vector. If it is a wall or a goal return empty vector else will return a path of all the square ID to reach the goal </dd></dl>
<p>Si il ne s'agit pas d'une case marquable comme deadSquare</p>

</div>
</div>
<a id="a5b4b5b6d151e6fb4388a26f5fea13c70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b4b5b6d151e6fb4388a26f5fea13c70">&#9670;&nbsp;</a></span>getPathSquareToSquareBM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; short &gt; Util::getPathSquareToSquareBM </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_maze.html">Maze</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>fromSquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>toSquare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the path beetween the squareID send in parameters and the toSquare goal. If no possible path, return null path is the id of all the square BM: box movement (path is like a path if we push a box)</p>
<p>Return the path beetween the fromSquare send in parameters and the toSquare . If no possible path, return empty vector path is the id of all the square. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">:fromSquare</td><td>number of the square in the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the square can not reached a goal, return empty vector. If it is a wall or a goal return empty vector else will return a path of all the square ID to reach the goal calculating in "pushingBox movement" </dd></dl>
<p>Si il ne s'agit pas d'une case marquable comme deadSquare</p>

</div>
</div>
<a id="afc64fdff8e06835f673d329db43c9ce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc64fdff8e06835f673d329db43c9ce3">&#9670;&nbsp;</a></span>getPathSquareToSquarePM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; short &gt; Util::getPathSquareToSquarePM </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_maze.html">Maze</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>fromSquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>toSquare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the path beetween the fromSquare send in parameters and the toSquare . If no possible path, return empty vector path is the id of all the square. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">:fromSquare</td><td>number of the square in the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the square can not reached a goal, return empty vector. If it is a wall or a goal return empty vector else will return a path of all the square ID to reach the goal calculating in "moving player movement" </dd></dl>
<p>Si il ne s'agit pas d'une case marquable comme deadSquare</p>

</div>
</div>
<a id="afdcf4621797b62bd2a1268000a62556c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdcf4621797b62bd2a1268000a62556c">&#9670;&nbsp;</a></span>getPathSquareToSquareZoneMethod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_node_1_1_node_retrack_info.html">Node::NodeRetrackInfo</a> &gt; Util::getPathSquareToSquareZoneMethod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_maze.html">Maze</a> *&#160;</td>
          <td class="paramname"><em>orM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>fromSquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>toSquare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>posPlayer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>return the path beewteen fromSquare and toSquare with BFSPlus like method </p>
<p>We set the game in the state</p>
<p>we look for pushed all boxes in all directions possibles</p>

</div>
</div>
<a id="a447f63eecf30c3258e5bf7b8e32f3864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a447f63eecf30c3258e5bf7b8e32f3864">&#9670;&nbsp;</a></span>relier_point()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned short &gt; Util::relier_point </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_maze.html">Maze</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned short &gt;&#160;</td>
          <td class="paramname"><em>positions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>this method will receive a vector of succesive position. it will give in return a vector of move directctive to follow in passed through each position of the vector </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="util_8h_source.html">util.h</a></li>
<li><a class="el" href="util_8cpp.html">util.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_util.html">Util</a></li>
    <li class="footer">Generated on Fri Jun 7 2019 16:48:55 for new_sokoban_solver by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
